#usda 1.0
(
    defaultPrim = "World"
    metersPerUnit = 0.01
    upAxis = "Z"
    startTimeCode = 0
    endTimeCode = 1000
    timeCodesPerSecond = 100
)

def Xform "World"
{
    ############################################################################
    # PHYSICS SCENE
    ############################################################################
    def PhysicsScene "physicsScene"
    {
        vector3f physics:gravityDirection = (0, 0, -1)
        float physics:gravityMagnitude = 981
        uniform uint physxScene:minPositionIterationCount = 200
        uniform uint physxScene:minVelocityIterationCount = 200
        uint physxScene:timeStepsPerSecond = 60
    }

    ############################################################################
    # FLOOR
    ############################################################################
    def Mesh "groundPlane" (
        prepend apiSchemas = ["PhysicsCollisionAPI"]
    )
    {
        int[] faceVertexCounts = [4]
        int[] faceVertexIndices = [0, 1, 2, 3]
        point3f[] points = [
            (-25000, -25000, 0), 
            ( 25000, -25000, 0), 
            ( 25000,  25000, 0), 
            (-25000,  25000, 0)
        ]
        normal3f[] normals = [(0,0,1), (0,0,1), (0,0,1), (0,0,1)]
        color3f[] primvars:displayColor = [(0.55, 0.7, 1.0)]
    }

    ############################################################################
    # A SIMPLE PHYSICS MATERIAL
    ############################################################################
    def Material "PhysicsMaterial" (
        prepend apiSchemas = ["PhysicsMaterialAPI"]
    )
    {
        float physics:dynamicFriction = 0.5
        float physics:staticFriction = 0.5
        float physics:restitution = 0.0
    }

    ############################################################################
    # TABLE (STATIC RIGID BODY)
    ############################################################################
    def Scope "Table"
    {
        # Table top
        def Cube "tableTopActor" (
            prepend apiSchemas = ["PhysicsCollisionAPI","PhysicsRigidBodyAPI","PhysicsMassAPI","PhysxCollisionAPI","MaterialBindingAPI"]
        )
        {
            token physxCollision:bodyType = "static"
            # float physics:density = 10000
            rel material:binding:physics = </World/PhysicsMaterial>
            float3[] extent = [(-0.5,-0.5,-0.5),(0.5,0.5,0.5)]
            color3f[] primvars:displayColor = [(0.66, 0.56, 0.47)]
            float[] primvars:displayOpacity = [1]
            double size = 1
            float3 xformOp:scale = (230, 130, 1)
            double3 xformOp:translate = (0, 0, 200.51)
            uniform token[] xformOpOrder = ["xformOp:translate","xformOp:scale"]
            # primvars:displayOpacity = 0.8
        }

        # Four legs
        def Cube "tableLeg0Actor" (
            prepend apiSchemas = ["PhysicsCollisionAPI","PhysicsRigidBodyAPI","PhysicsMassAPI","PhysxCollisionAPI","MaterialBindingAPI"]
        )
        {
            token physxCollision:bodyType = "static"
            rel material:binding:physics = </World/PhysicsMaterial>
            float3[] extent = [(-0.5,-0.5,-0.5),(0.5,0.5,0.5)]
            color3f[] primvars:displayColor = [(0.66, 0.56, 0.47)]
            double size = 1
            float3 xformOp:scale = (20,20,200)
            double3 xformOp:translate = (-100, -50, 100)
            uniform token[] xformOpOrder = ["xformOp:translate","xformOp:scale"]
        }

        def Cube "tableLeg1Actor" (
            prepend apiSchemas = ["PhysicsCollisionAPI","PhysicsRigidBodyAPI","PhysicsMassAPI","PhysxCollisionAPI","MaterialBindingAPI"]
        )
        {
            token physxCollision:bodyType = "static"
            rel material:binding:physics = </World/PhysicsMaterial>
            float3[] extent = [(-0.5,-0.5,-0.5),(0.5,0.5,0.5)]
            color3f[] primvars:displayColor = [(0.66, 0.56, 0.47)]
            double size = 1
            float3 xformOp:scale = (20,20,200)
            double3 xformOp:translate = (-100, 50, 100)
            uniform token[] xformOpOrder = ["xformOp:translate","xformOp:scale"]
        }

        def Cube "tableLeg2Actor" (
            prepend apiSchemas = ["PhysicsCollisionAPI","PhysicsRigidBodyAPI","PhysicsMassAPI","PhysxCollisionAPI","MaterialBindingAPI"]
        )
        {
            token physxCollision:bodyType = "static"
            rel material:binding:physics = </World/PhysicsMaterial>
            float3[] extent = [(-0.5,-0.5,-0.5),(0.5,0.5,0.5)]
            color3f[] primvars:displayColor = [(0.66, 0.56, 0.47)]
            double size = 1
            float3 xformOp:scale = (20,20,200)
            double3 xformOp:translate = (100, -50, 100)
            uniform token[] xformOpOrder = ["xformOp:translate","xformOp:scale"]
        }

        def Cube "tableLeg3Actor" (
            prepend apiSchemas = ["PhysicsCollisionAPI","PhysicsRigidBodyAPI","PhysicsMassAPI","PhysxCollisionAPI","MaterialBindingAPI"]
        )
        {
            token physxCollision:bodyType = "static"
            rel material:binding:physics = </World/PhysicsMaterial>
            float3[] extent = [(-0.5,-0.5,-0.5),(0.5,0.5,0.5)]
            color3f[] primvars:displayColor = [(0.66, 0.56, 0.47)]
            double size = 1
            float3 xformOp:scale = (20,20,200)
            double3 xformOp:translate = (100, 50, 100)
            uniform token[] xformOpOrder = ["xformOp:translate","xformOp:scale"]
        }

        def PhysxPhysicsJointInstancer "TablejointInstancer0"
        {
            # We have exactly ONE joint instance that references:
            #   body0Indices=[0] => rope instance #0
            #   body1Indices=[0] => "the 0th entry" in body1s (the table top)
            int[] physics:body0Indices = [0]
            rel physics:body0s = </World/Table/tableLeg0Actor>

            int[] physics:body1Indices = [0]
            # We reference the table top prim in an array (even though it's just 1 item)
            prepend rel physics:body1s = </World/Table/tableTopActor>

            # localPos0 = anchor on the capsule's end
            # localPos1 = anchor on the table top
            point3f[] physics:localPos0s = [(0, 0, 100)]
            point3f[] physics:localPos1s = [(-100, -50, -0.5)]
            quath[] physics:localRot0s = [(1,0,0,0)]
            quath[] physics:localRot1s = [(1,0,0,0)]

            int[] physics:protoIndices = [0]
            prepend rel physics:prototypes = </World/Rope0/ropeTableAttachment/fixedJoint>

            def PhysicsFixedJoint "fixedJoint"()
            {
                # A FixedJoint has no extra limits or drives; it's locked in place
            }
        }

        def PhysxPhysicsJointInstancer "TablejointInstancer1"
        {
            # We have exactly ONE joint instance that references:
            #   body0Indices=[0] => rope instance #0
            #   body1Indices=[0] => "the 0th entry" in body1s (the table top)
            int[] physics:body0Indices = [0]
            rel physics:body0s = </World/Table/tableLeg1Actor>

            int[] physics:body1Indices = [0]
            # We reference the table top prim in an array (even though it's just 1 item)
            prepend rel physics:body1s = </World/Table/tableTopActor>

            # localPos0 = anchor on the capsule's end
            # localPos1 = anchor on the table top
            point3f[] physics:localPos0s = [(0, 0, 100)]
            point3f[] physics:localPos1s = [(-100, 50, -0.5)]
            quath[] physics:localRot0s = [(1,0,0,0)]
            quath[] physics:localRot1s = [(1,0,0,0)]

            int[] physics:protoIndices = [0]
            prepend rel physics:prototypes = </World/Rope0/ropeTableAttachment/fixedJoint>

            def PhysicsFixedJoint "fixedJoint"()
            {
                # A FixedJoint has no extra limits or drives; it's locked in place
            }
        }

        def PhysxPhysicsJointInstancer "TablejointInstancer2"
        {
            # We have exactly ONE joint instance that references:
            #   body0Indices=[0] => rope instance #0
            #   body1Indices=[0] => "the 0th entry" in body1s (the table top)
            int[] physics:body0Indices = [0]
            rel physics:body0s = </World/Table/tableLeg1Actor>

            int[] physics:body1Indices = [0]
            # We reference the table top prim in an array (even though it's just 1 item)
            prepend rel physics:body1s = </World/Table/tableTopActor>

            # localPos0 = anchor on the capsule's end
            # localPos1 = anchor on the table top
            point3f[] physics:localPos0s = [(0, 0, 100)]
            point3f[] physics:localPos1s = [(100, -50, -0.5)]
            quath[] physics:localRot0s = [(1,0,0,0)]
            quath[] physics:localRot1s = [(1,0,0,0)]

            int[] physics:protoIndices = [0]
            prepend rel physics:prototypes = </World/Rope0/ropeTableAttachment/fixedJoint>

            def PhysicsFixedJoint "fixedJoint"()
            {
                # A FixedJoint has no extra limits or drives; it's locked in place
            }
        }

        def PhysxPhysicsJointInstancer "TablejointInstancer3"
        {
            # We have exactly ONE joint instance that references:
            #   body0Indices=[0] => rope instance #0
            #   body1Indices=[0] => "the 0th entry" in body1s (the table top)
            int[] physics:body0Indices = [0]
            rel physics:body0s = </World/Table/tableLeg1Actor>

            int[] physics:body1Indices = [0]
            # We reference the table top prim in an array (even though it's just 1 item)
            prepend rel physics:body1s = </World/Table/tableTopActor>

            # localPos0 = anchor on the capsule's end
            # localPos1 = anchor on the table top
            point3f[] physics:localPos0s = [(0, 0, 100)]
            point3f[] physics:localPos1s = [(100, 50, -0.5)]
            quath[] physics:localRot0s = [(1,0,0,0)]
            quath[] physics:localRot1s = [(1,0,0,0)]

            int[] physics:protoIndices = [0]
            prepend rel physics:prototypes = </World/Rope0/ropeTableAttachment/fixedJoint>

            def PhysicsFixedJoint "fixedJoint"()
            {
                # A FixedJoint has no extra limits or drives; it's locked in place
            }
        }
    }

    ############################################################################
    # ROPE (POINTINSTANCER WITH 26 SEGMENTS)
    ############################################################################
    def Scope "Rope0"
    {
        #
        # 26 capsules: the first 25 are capsules; the last one is a payload
        #
        def PointInstancer "rigidBodyInstancer"
        {
            point3f[] positions = [
                # (0, 0, 198), (0, 0, 194), (0, 0, 190), (0, 0, 186), (0, 0, 182),
                # (0, 0, 178), (0, 0, 174), (0, 0, 170), (0, 0, 166), (0, 0, 162),
                # (0, 0, 158), (0, 0, 154), (0, 0, 150), (0, 0, 146), (0, 0, 142),
                # (0, 0, 138), (0, 0, 134), (0, 0, 130), (0, 0, 126), (0, 0, 122),
                # (0, 0, 118), (0, 0, 114), (0, 0, 110), (0, 0, 106), (0, 0, 102),
                # (0, 0, 98)
                (0, 0, 196), (0, 0, 188), (0, 0, 180), (0, 0, 172), (0, 0, 164),
                (0, 0, 156), (0, 0, 148), (0, 0, 140), (0, 0, 132), (0, 0, 124)
            ]
            quath[] orientations = [
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0), (0.707031,0,0.707031,0),
                # (0.707031,0,0.707031,0), (0.707031,0,0.707031,0)
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0)
                (1,0,0,0),(1,0,0,0),(1,0,0,0),
                (1,0,0,0),(1,0,0,0),(1,0,0,0),
                (1,0,0,0),(1,0,0,0),(1,0,0,0),
                (1,0,0,0)
            ]
            # Proto #0 = Capsule, Proto #1 = Payload
            int[] protoIndices = [
                # 0,0,0,0,0,0,0,0,0,0,
                # 0,0,0,0,0,0,0,0,0,0,
                # 0,0,0,0,0, 1
                0,0,0,0,0,0,0,0,0,1
            ]
            prepend rel prototypes = [
                </World/Rope0/rigidBodyInstancer/capsule>,
                </World/Rope0/rigidBodyInstancer/payload>
            ]

            def Capsule "capsule" (
                prepend apiSchemas = ["PhysicsCollisionAPI","PhysicsRigidBodyAPI","PhysicsMassAPI","PhysxCollisionAPI","MaterialBindingAPI"]
            )
            {
                # uniform token axis = "X"
                uniform token axis = "Z"
                double height = 6
                double radius = 1
                float physics:density = 0.1
                float physxCollision:contactOffset = 2
                float physxCollision:restOffset = 0
                rel material:binding:physics = </World/PhysicsMaterial>
                color3f[] primvars:displayColor = [(0.12, 0.24, 1.0)]
            }

            def Cube "payload" (
                prepend apiSchemas = ["PhysicsCollisionAPI","PhysicsRigidBodyAPI","PhysicsMassAPI","PhysxCollisionAPI","MaterialBindingAPI"]
            )
            {
                double size = 8
                float physics:density = 0.1
                float physxCollision:contactOffset = 4
                float physxCollision:restOffset = 0
                rel material:binding:physics = </World/PhysicsMaterial>
                color3f[] primvars:displayColor = [(0.8, 0, 0)]
            }
        }

        #
        # JOINT INSTANCER FOR LINKING CAPSULES 0..24 TO 1..25
        #
        def PhysxPhysicsJointInstancer "jointInstancer"
        {
            # 25 joints in the chain
            int[] physics:body0Indices = [
                0,1,2,3,4,5,6,7,8
                # 10,11,12,13,14,15,16,17,18,19,
                # 20,21,22,23,24
            ]
            rel physics:body0s = </World/Rope0/rigidBodyInstancer>
            int[] physics:body1Indices = [
                1,2,3,4,5,6,7,8,9
                # 11,12,13,14,15,16,17,18,19,20,
                # 21,22,23,24,25
            ]
            rel physics:body1s = </World/Rope0/rigidBodyInstancer>

            # Each link meets end-to-end (capsule ~4 units long)
            point3f[] physics:localPos0s = [
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0)
                # (0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),
                # (0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),
                # (0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),
                # (0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),
                # (0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2),(0,0,-2)
                (0,0,-4),(0,0,-4),(0,0,-4),(0,0,-4),(0,0,-4),
                (0,0,-4),(0,0,-4),(0,0,-4),(0,0,-4)
            ]
            point3f[] physics:localPos1s = [
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),
                # (-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0),(-2,0,0)
                # (2,0,0),(2,0,0),(2,0,0),(2,0,0),(2,0,0),
                # (2,0,0),(2,0,0),(2,0,0),(2,0,0),(2,0,0),
                # (2,0,0),(2,0,0),(2,0,0),(2,0,0),(2,0,0),
                # (2,0,0),(2,0,0),(2,0,0),(2,0,0),(2,0,0),
                # (2,0,0),(2,0,0),(2,0,0),(2,0,0),(2,0,0)
                # (0,0,2),(0,0,2),(0,0,2),(0,0,2),(0,0,2),
                # (0,0,2),(0,0,2),(0,0,2),(0,0,2),(0,0,2),
                # (0,0,2),(0,0,2),(0,0,2),(0,0,2),(0,0,2),
                # (0,0,2),(0,0,2),(0,0,2),(0,0,2),(0,0,2),
                # (0,0,2),(0,0,2),(0,0,2),(0,0,2),(0,0,2)
                (0,0,4),(0,0,4),(0,0,4),(0,0,4),(0,0,4),
                (0,0,4),(0,0,4),(0,0,4),(0,0,4)
            ]
            quath[] physics:localRot0s = [
                (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),
                (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0)
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0)
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
            ]
            quath[] physics:localRot1s = [
                (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),
                (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0)
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),
                # (1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0)
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
                # (0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),
            ]
            int[] physics:protoIndices = [
                0,0,0,0,0, 0,0,0,0
                # 0,0,0,0,0, 0,0,0,0,0,
                # 0,0,0,0,0
            ]
            prepend rel physics:prototypes = </World/Rope0/jointInstancer/chainJoint>

            # def PhysicsJoint "chainJoint" (
            #     prepend apiSchemas = [
            #         "PhysicsLimitAPI:transX","PhysicsDriveAPI:transX",
            #         "PhysicsLimitAPI:transY","PhysicsLimitAPI:transZ",
            #         "PhysicsLimitAPI:rotX",  "PhysicsLimitAPI:rotY","PhysicsDriveAPI:rotY",
            #         "PhysicsLimitAPI:rotZ",  "PhysicsDriveAPI:rotZ"
            #     ]
            # )
            # {
            #     # Basic limit corrections
            #     float limit:rotX:physics:low = -1
            #     float limit:rotX:physics:high = 1
            #     float limit:rotY:physics:low = -160
            #     float limit:rotY:physics:high = 160
            #     float limit:rotZ:physics:low = -160
            #     float limit:rotZ:physics:high = 160
            #     float limit:transX:physics:low = -10
            #     float limit:transX:physics:high = 10
            #     float limit:transY:physics:low = -1
            #     float limit:transY:physics:high = 1
            #     float limit:transZ:physics:low = -1
            #     float limit:transZ:physics:high = 1
            # }
            def PhysicsJoint "chainJoint" (
                prepend apiSchemas = ["PhysicsLimitAPI:transX", "PhysicsDriveAPI:transZ", "PhysicsLimitAPI:transY", "PhysicsLimitAPI:transZ", "PhysicsLimitAPI:rotX", "PhysicsLimitAPI:rotY", "PhysicsDriveAPI:rotY", "PhysicsLimitAPI:rotZ", "PhysicsDriveAPI:rotX"]
                # prepend apiSchemas = ["PhysicsLimitAPI:transX", "PhysicsLimitAPI:transY", "PhysicsLimitAPI:transZ", "PhysicsLimitAPI:rotX", "PhysicsLimitAPI:rotY",  "PhysicsLimitAPI:rotZ"]
            )
            {
                float drive:rotY:physics:damping = 0.1
                float drive:rotY:physics:stiffness = 0.1
                uniform token drive:rotY:physics:type = "force"
                float drive:rotX:physics:damping = 0.1
                float drive:rotX:physics:stiffness = 0.1
                uniform token drive:rotX:physics:type = "force"
                float drive:transZ:physics:damping = 100
                float drive:transZ:physics:stiffness = 1000000
                uniform token drive:transZ:physics:type = "force"
                float limit:rotX:physics:high = 110
                float limit:rotX:physics:low = -110
                float limit:rotY:physics:high = 110
                float limit:rotY:physics:low = -110
                float limit:rotZ:physics:high = -110
                float limit:rotZ:physics:low = 110
                float limit:transX:physics:high = -1
                float limit:transX:physics:low = 1
                float limit:transY:physics:high = -1
                float limit:transY:physics:low = 1
                float limit:transZ:physics:high = -1
                float limit:transZ:physics:low = 1
            }
            # def PhysicsJoint "chainJoint" (
            #     prepend apiSchemas = ["PhysicsLimitAPI:transX", "PhysicsLimitAPI:transY", "PhysicsLimitAPI:transZ", "PhysicsLimitAPI:rotX", "PhysicsLimitAPI:rotY", "PhysicsDriveAPI:rotY", "PhysicsLimitAPI:rotZ", "PhysicsDriveAPI:rotZ"]
            # )
            # {
            #     float drive:rotY:physics:damping = 10
            #     float drive:rotY:physics:stiffness = 1
            #     uniform token drive:rotY:physics:type = "force"
            #     float drive:rotZ:physics:damping = 10
            #     float drive:rotZ:physics:stiffness = 1
            #     uniform token drive:rotZ:physics:type = "force"
            #     float limit:rotX:physics:high = -1
            #     float limit:rotX:physics:low = 1
            #     float limit:rotY:physics:high = 110
            #     float limit:rotY:physics:low = -110
            #     float limit:rotZ:physics:high = 110
            #     float limit:rotZ:physics:low = -110
            #     float limit:transX:physics:high = -1
            #     float limit:transX:physics:low = 1
            #     float limit:transY:physics:high = -1
            #     float limit:transY:physics:low = 1
            #     float limit:transZ:physics:high = -1
            #     float limit:transZ:physics:low = 1
            # }
        }

        ############################################################################
        # ATTACHING THE FIRST ROPE SEGMENT (INSTANCE #0) TO THE TABLE
        ############################################################################
        def PhysxPhysicsJointInstancer "ropeTableAttachment"
        {
            # We have exactly ONE joint instance that references:
            #   body0Indices=[0] => rope instance #0
            #   body1Indices=[0] => "the 0th entry" in body1s (the table top)
            int[] physics:body0Indices = [0]
            rel physics:body0s = </World/Rope0/rigidBodyInstancer>

            int[] physics:body1Indices = [0]
            # We reference the table top prim in an array (even though it's just 1 item)
            prepend rel physics:body1s = </World/Table/tableTopActor>

            # localPos0 = anchor on the capsule's end
            # localPos1 = anchor on the table top
            point3f[] physics:localPos0s = [(0, 0, 4)]
            point3f[] physics:localPos1s = [(0, 0, -0.5)]
            quath[] physics:localRot0s = [(0,0,0,0)]
            quath[] physics:localRot1s = [(0,0,0,0)]

            int[] physics:protoIndices = [0]
            prepend rel physics:prototypes = </World/Rope0/ropeTableAttachment/attachJoint>

            def PhysicsJoint "attachJoint" (
                prepend apiSchemas = ["PhysicsLimitAPI:transX", "PhysicsLimitAPI:transY", "PhysicsLimitAPI:transZ", "PhysicsLimitAPI:rotX", "PhysicsLimitAPI:rotY", "PhysicsDriveAPI:rotY", "PhysicsLimitAPI:rotZ", "PhysicsDriveAPI:rotZ"]
            )
            {
                float drive:rotY:physics:damping = 10
                float drive:rotY:physics:stiffness = 1
                uniform token drive:rotY:physics:type = "force"
                float drive:rotZ:physics:damping = 10
                float drive:rotZ:physics:stiffness = 1
                uniform token drive:rotZ:physics:type = "force"
                float limit:rotX:physics:high = -1
                float limit:rotX:physics:low = 1
                float limit:rotY:physics:high = 110
                float limit:rotY:physics:low = -110
                float limit:rotZ:physics:high = 110
                float limit:rotZ:physics:low = -110
                float limit:transX:physics:high = -1
                float limit:transX:physics:low = 1
                float limit:transY:physics:high = -1
                float limit:transY:physics:low = 1
                float limit:transZ:physics:high = -1
                float limit:transZ:physics:low = 1
            }
        }

    } # end Rope0 scope

} # end World
